



## Router Props - match, location, history

라우터로 렌더링하는 컴포넌트에는 props로 match, location, history라는 객체가 전달된다.

각 객체들을 console로 찍어보면 대략

![image](https://user-images.githubusercontent.com/75282888/114065978-2f5d5080-98d6-11eb-9cd1-214e415e7fba.png)

맨 위부터 location,  match, history 이다.



### query

##### query = qs.parse(location.search, { ignoreQueryPrefix: true }) 

// 별도로 ignoreQueryPrefix옵션을 설정하지 않으면 물음표까지 같이 딸려서 파싱된다. 무조건 true로 설정해야 한다.

query값은 location객체의 search프로퍼티에 담겨있다. 단 정말로 문자열 형태로 담겨 있기 때문에 qs라는 라이브러리를 통해 객체형태로 파싱을 해줘야 한다. 



### Params

##### params = match.params

params값은 match객체의 params 프로퍼티에 담겨있다. 객체형태로 아주 잘 담겨 있으니 바로 사용하면 된다.



### History

##### history.push('/')

원하는 url로 돌아갈 수 있다. history api를 더 공부해야 할 거 같은데, 아무 곳으로 갈 수 있는 것이 아니라 거쳐온 곳으로만 돌아갈 수 있는 것 같다.

##### history.block('원하는 msg')

공부해야 함.  alert함수처럼 경고창이 뜬다. 차이가 있을 것이다. 알아봐야겠다.



##### history.goBack()

뒤로 가기다. Link객체 등을 통해 웹 어플리케이션 안에서 이동한 경우에 한해서 가능한 것으로 보인다. 해당 URL을 직접 입력해서 접근한 경우 해당 메서드가 작동하지 않는 것 같다. 뇌피셜이다.



참고 자료) 시간 되면 읽어봐야 함 

https://medium.com/@mcastorena0316/react-routes-the-wonders-of-match-history-and-location-3c525ba7d48b

https://developer.mozilla.org/ko/docs/Web/API/History_API







## withRouter HoC

라우트로 렌더링 되는 컴포넌트가 아닌, 다른 컴포넌트에서 match, location, history를 사용할 때

withRouter HoC [^1]를 쓴다.

[^1]:HoC, Higher Order Component, 고차 컴포넌트



withRouter 를 사용하면, 자신의 부모 컴포넌트 기준의 match 값이 전달된다.

​		



## Switch

Switch를 여러 Route들을 감싸서 그 중 단 하나의 라우터만을 렌더링 시킨다.

Switch를 사용하면, url이 어떠한 path와도 일치하지 않을 때 Not Found페이지를 구현할 수 있다.





## NavLink

NavLink는 Link랑 비슷한데, 현재 경로와 NavLink가 사용하는 경로와 일치하는 경우 특별한 스타일 혹은 클래스를 적용할 수 있는 컴포넌트이다. 원하는 스타일을 activeStyle 혹은 activeClassName에 전달하면 된다.





